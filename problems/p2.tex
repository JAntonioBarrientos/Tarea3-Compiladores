\begin{Pro}
   Define una gramática para los operadores booleanos \texttt{not}, \texttt{and} y \texttt{or}. Define funciones para parsar del árbol concreto al árbol de sintaxis abstracta (DAG). Construye los árboles concretos y abstractos para:
\begin{enumerate}
    \item[(a)] $(\texttt{True or } x) \texttt{ and True}$
    \item[(b)] $(x \texttt{ or False}) \texttt{ and } (y \texttt{ and True})$
    \item[(c)] $(\texttt{True or False}) \texttt{ and } (\texttt{not } x)$
    \item[(d)] $\texttt{not } (\texttt{True or } x) \texttt{ and } (\texttt{False or } y) \texttt{ or } (x \texttt{ and } y)$
\end{enumerate}
 
\end{Pro}


Definimos la gramática libre de contexto para expresiones booleanas. Para respetar la precedencia estándar ($\texttt{not} > \texttt{and} > \texttt{or}$), utilizamos:
\begin{center}
\renewcommand{\arraystretch}{1.5}
\begin{tabular}{l @{\hspace{1.5cm}} l}
    \toprule
    \textbf{Producción} & \textbf{Reglas Semánticas (Construcción del DAG)} \\
    \midrule
    % Nivel Expresión (OR - Menor precedencia)
    $B \to B_1 \texttt{ or } T$ & $B.node = \text{new Node}(\texttt{'or'}, B_1.node, T.node)$ \\
    $B \to T$       & $B.node = T.node$ \\
    \midrule
    % Nivel Término (AND - Precedencia media)
    $T \to T_1 \texttt{ and } F$ & $T.node = \text{new Node}(\texttt{'and'}, T_1.node, F.node)$ \\
    $T \to F$       & $T.node = F.node$ \\
    \midrule
    % Nivel Factor (NOT, Paréntesis y Literales - Mayor precedencia)
    $F \to \texttt{not } F_1$     & $F.node = \text{new Node}(\texttt{'not'}, F_1.node, \text{null})$ \\
    $F \to (B)$     & $F.node = B.node$ \\
    $F \to \textbf{True}$ & $F.node = \text{new Leaf}(\textbf{True}, \text{val}(\text{True}))$ \\
    $F \to \textbf{False}$ & $F.node = \text{new Leaf}(\textbf{False}, \text{val}(\text{False}))$ \\
    $F \to \textbf{id}$ & $F.node = \text{new Leaf}(\textbf{id}, \text{getname}(\textbf{id}))$ \\
    \bottomrule
\end{tabular}
\end{center}
\footnotesize{Nota: El operador unario \texttt{not} se aplica sobre el Factor ($F$). Los subíndices (ej. $B_1$) denotan la instancia recursiva del lado derecho.}
\normalsize



Para la construcción del DAG, se asume que las funciones constructoras (new Node, new Leaf) verifican primero si ya existe un nodo idéntico en la gráfica antes de crear uno nuevo (Value-Number Method).

Primero mostraremos los árboles abstractos y luego los árboles concretos para cada expresión

\begin{enumerate}
    \item[(a)] $(\texttt{True or } x) \texttt{ and True}$
    
    \begin{center}
        % Espacio para Árbol Concreto
        \includegraphics[width=0.5\textwidth]{images/p2/p2a_asa.jpg}
        
    
        \includegraphics[width=0.5\textwidth]{images/p2/p2a_concreto.jpg}

    \end{center}

    \item[(b)] $(x \texttt{ or False}) \texttt{ and } (y \texttt{ and True})$
    
    \begin{center}
        \includegraphics[width=0.5\textwidth]{images/p2/p2b_asa.jpg}
        \hfill

        \includegraphics[width=0.5\textwidth]{images/p2/p2b_concreto.jpg}
    \end{center}

    \item[(c)] $(\texttt{True or False}) \texttt{ and } (\texttt{not } x)$
    
    \begin{center}
        \includegraphics[width=0.5\textwidth]{images/p2/p2c_asa.jpg}
        \hfill
        \includegraphics[width=0.5\textwidth]{images/p2/p2c_concreto.jpg}
    \end{center}

    \item[(d)] $\texttt{not } (\texttt{True or } x) \texttt{ and } (\texttt{False or } y) \texttt{ or } (x \texttt{ and } y)$
    
    \begin{center}
        
        \includegraphics[width=0.7\textwidth]{images/p2/p2d_asa.jpg} \\[1em]


        \includegraphics[width=0.8\textwidth]{images/p2/p2d_concreto.jpg}
    \end{center}
\end{enumerate}